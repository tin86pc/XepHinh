<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>üïπÔ∏è X·∫øp H√¨nh</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üïπÔ∏è</text></svg>">

<!-- Th√™m th∆∞ vi·ªán QR Code -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  touch-action: manipulation;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #0d001a;
  font-family: 'Arial', sans-serif;
}

body {
  display: flex;
  flex-direction: column;
  color: white;
}

/* Header */
.game-header {
  height: 60px;
  min-height: 60px;
  display: flex;
  justify-content: center;
  align-items: center;
  background: linear-gradient(180deg, #0a001a 0%, #090014 100%);
  padding: 0 15px;
}

.score-display {
  display: flex;
  gap: 25px;
}

.score-item {
  font-size: 18px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.score-label {
  font-size: 14px;
  color: #a78bfa;
  opacity: 0.8;
}

.score-value {
  font-size: 22px;
  font-weight: bold;
  color: #ffeb3b;
  text-shadow: 0 0 10px rgba(255,235,59,0.5);
}

#level {
  color: #4fc3f7;
  text-shadow: 0 0 10px rgba(79,195,247,0.5);
}

#speed {
  color: #ff9800;
  text-shadow: 0 0 10px rgba(255,152,0,0.5);
}

/* Game area */
.main-game-area {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
  position: relative;
  background: linear-gradient(180deg, #0d001a 0%, #090014 100%);
}

/* Canvas */
#game {
  background: #0a0014;
  border: 3px solid #5a3eff;
  border-radius: 12px;
  box-shadow: 
    0 0 30px rgba(90,60,255,0.6),
    inset 0 0 20px rgba(0,0,0,0.5);
}

/* Pause Overlay */
.pause-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(5px);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 100;
  border-radius: 12px;
  padding: 20px;
  text-align: center;
}

.pause-overlay.show {
  display: flex;
}

.pause-title {
  font-size: 32px;
  color: #ff5722;
  margin-bottom: 15px;
  font-weight: bold;
  text-shadow: 0 0 15px rgba(255,87,34,0.7);
}

.pause-text {
  font-size: 18px;
  color: #e0e0ff;
  margin: 5px 0;
  text-align: center;
  padding: 0 20px;
}

/* QR Code Container */
.qr-container {
  margin: 20px 0;
  padding: 15px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 10px;
  border: 2px solid #5a3eff;
  max-width: 90%;
}

.qr-title {
  font-size: 16px;
  color: #4fc3f7;
  margin-bottom: 10px;
}

#qrcode {
  background: white;
  padding: 10px;
  border-radius: 8px;
  display: inline-block;
}

.qr-link {
  font-size: 14px;
  color: #a78bfa;
  margin-top: 10px;
  word-break: break-all;
}

/* Controls */
.controls-container {
  height: 100px;
  min-height: 100px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: linear-gradient(180deg, #090014 0%, #0a001a 100%);
  gap: 10px;
}

.control-row {
  display: flex;
  gap: 25px;
}

.icon-button {
  width: 65px;
  height: 65px;
  border-radius: 50%;
  border: none;
  font-size: 28px;
  background: linear-gradient(145deg, #673ab7, #5e35b1);
  color: white;
  box-shadow: 
    0 4px 15px rgba(103,58,183,0.6),
    0 -2px 5px rgba(255,255,255,0.1) inset;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

.icon-button:active {
  transform: scale(0.95);
  box-shadow: 
    0 2px 8px rgba(103,58,183,0.4),
    0 -1px 3px rgba(255,255,255,0.1) inset;
}

.icon-button.pause {
  background: linear-gradient(145deg, #ff5722, #e64a19);
  box-shadow: 
    0 4px 15px rgba(255,87,34,0.6),
    0 -2px 5px rgba(255,255,255,0.1) inset;
}

.icon-button.fullscreen {
  background: linear-gradient(145deg, #2196f3, #1976d2);
  box-shadow: 
    0 4px 15px rgba(33,150,243,0.6),
    0 -2px 5px rgba(255,255,255,0.1) inset;
}

.icon-button.sound {
  background: linear-gradient(145deg, #4CAF50, #388E3C);
  box-shadow: 
    0 4px 15px rgba(76,175,80,0.6),
    0 -2px 5px rgba(255,255,255,0.1) inset;
}

.icon-button.muted {
  background: linear-gradient(145deg, #757575, #616161);
  box-shadow: 
    0 4px 15px rgba(117,117,117,0.6),
    0 -2px 5px rgba(255,255,255,0.1) inset;
}

.icon-button::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3) 0%, transparent 70%);
  pointer-events: none;
}

/* Th√¥ng b√°o t∆∞∆°ng t√°c */
.tap-hint {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  color: #a78bfa;
  opacity: 0.8;
  pointer-events: none;
  transition: opacity 0.5s;
}

/* Mobile adjustments */
@media (max-height: 700px) {
  .game-header {
    height: 50px;
    min-height: 50px;
  }
  
  .score-item {
    font-size: 16px;
  }
  
  .score-value {
    font-size: 20px;
  }
  
  .controls-container {
    height: 90px;
    min-height: 90px;
  }
  
  .icon-button {
    width: 60px;
    height: 60px;
    font-size: 26px;
  }
  
  .pause-title {
    font-size: 28px;
  }
  
  .pause-text {
    font-size: 16px;
  }
  
  .qr-container {
    margin: 10px 0;
    padding: 10px;
  }
  
  #qrcode {
    transform: scale(0.9);
  }
}

@media (max-height: 600px) {
  .game-header {
    height: 45px;
    min-height: 45px;
  }
  
  .controls-container {
    height: 80px;
    min-height: 80px;
  }
  
  .icon-button {
    width: 55px;
    height: 55px;
    font-size: 24px;
  }
  
  .qr-container {
    margin: 5px 0;
  }
  
  #qrcode {
    transform: scale(0.8);
  }
}

@media (max-height: 500px) {
  .controls-container {
    height: 70px;
    min-height: 70px;
  }
  
  .icon-button {
    width: 50px;
    height: 50px;
    font-size: 22px;
  }
}

/* Hide scrollbars */
::-webkit-scrollbar {
  display: none;
}
</style>
</head>

<body>

<div class="game-header">
  <div class="score-display">
    <div class="score-item">
      <div class="score-label">ƒêI·ªÇM</div>
      <div class="score-value" id="score">0</div>
    </div>
    <div class="score-item">
      <div class="score-label">LEVEL</div>
      <div class="score-value" id="level">1</div>
    </div>
    <div class="score-item">
      <div class="score-label">T·ªêC ƒê·ªò</div>
      <div class="score-value" id="speed">1x</div>
    </div>
  </div>
</div>

<div class="main-game-area">
  <canvas id="game"></canvas>
  <div class="tap-hint" id="tapHint">üëÜ Ch·∫°m ƒë·ªÉ xoay, vu·ªët ƒë·ªÉ di chuy·ªÉn</div>
  
  <div class="pause-overlay" id="pauseOverlay">
    <div class="pause-title">‚è∏Ô∏è T·∫†M D·ª™NG</div>
    <div class="pause-text">Nh·∫•n n√∫t ‚ñ∂Ô∏è ƒë·ªÉ ti·∫øp t·ª•c</div>
    
    <!-- QR Code Section -->
    <div class="qr-container">
      <div class="qr-title">üîó Chia s·∫ª game n√†y:</div>
      <div id="qrcode"></div>
      <div class="qr-link">tin86pc.github.io/XepHinh/</div>
    </div>
  </div>
</div>

<div class="controls-container">
  <div class="control-row">
    <button class="icon-button pause" id="pauseBtn" onclick="togglePause()" title="D·ª´ng/Ti·∫øp t·ª•c">
      ‚è∏Ô∏è
    </button>
    <button class="icon-button fullscreen" onclick="toggleFullscreen()" title="To√†n m√†n h√¨nh">
      ‚õ∂
    </button>
    <button class="icon-button sound" id="soundBtn" onclick="toggleSound()" title="B·∫≠t/T·∫Øt √¢m thanh">
      üîä
    </button>
  </div>
</div>

<script>
// ===================== CONFIG =====================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const tapHint = document.getElementById("tapHint");
const pauseOverlay = document.getElementById("pauseOverlay");

const COLS = 10;
const ROWS = 20;
const BLOCK = 30;

const COLORS = [
  null, 
  "#00FFFF",  // I - Cyan
  "#FFFF00",  // O - Yellow
  "#800080",  // T - Purple
  "#0000FF",  // J - Blue
  "#FFA500",  // L - Orange
  "#00FF00",  // S - Green
  "#FF0000"   // Z - Red
];

// Shape definitions v·ªõi t·∫•t c·∫£ c√°c rotation
const SHAPES = {
  1: { // I
    0: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
    1: [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]],
    2: [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
    3: [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]
  },
  2: { // O
    0: [[1,1],[1,1]],
    1: [[1,1],[1,1]],
    2: [[1,1],[1,1]],
    3: [[1,1],[1,1]]
  },
  3: { // T
    0: [[0,1,0],[1,1,1],[0,0,0]],
    1: [[1,0],[1,1],[1,0]],
    2: [[1,1,1],[0,1,0],[0,0,0]],
    3: [[0,1],[1,1],[0,1]]
  },
  4: { // J
    0: [[1,0,0],[1,1,1],[0,0,0]],
    1: [[1,1],[1,0],[1,0]],
    2: [[1,1,1],[0,0,1],[0,0,0]],
    3: [[0,1],[0,1],[1,1]]
  },
  5: { // L
    0: [[0,0,1],[1,1,1],[0,0,0]],
    1: [[1,0],[1,0],[1,1]],
    2: [[1,1,1],[1,0,0],[0,0,0]],
    3: [[1,1],[0,1],[0,1]]
  },
  6: { // S
    0: [[0,1,1],[1,1,0],[0,0,0]],
    1: [[0,1,0],[0,1,1],[0,0,1]],
    2: [[0,0,0],[0,1,1],[1,1,0]],
    3: [[1,0,0],[1,1,0],[0,1,0]]
  },
  7: { // Z
    0: [[1,1,0],[0,1,1],[0,0,0]],
    1: [[0,0,1],[0,1,1],[0,1,0]],
    2: [[0,0,0],[1,1,0],[0,1,1]],
    3: [[0,1,0],[1,1,0],[1,0,0]]
  }
};

// Wall kicks cho Tetris theo chu·∫©n SRS
const WALL_KICKS = {
  1: { // I piece
    "0->1": [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
    "1->0": [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
    "1->2": [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
    "2->1": [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
    "2->3": [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
    "3->2": [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
    "3->0": [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
    "0->3": [[0,0], [-1,0], [2,0], [-1,2], [2,-1]]
  },
  default: { // Other pieces
    "0->1": [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
    "1->0": [[0,0], [1,0], [1,-1], [0,2], [1,2]],
    "1->2": [[0,0], [1,0], [1,-1], [0,2], [1,2]],
    "2->1": [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
    "2->3": [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
    "3->2": [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
    "3->0": [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
    "0->3": [[0,0], [1,0], [1,1], [0,-2], [1,-2]]
  }
};

// Th√™m extra kicks cho c√°c kh·ªëi khi s√°t t∆∞·ªùng
const EXTRA_KICKS = [
  [0, 0],   // G·ªëc
  [1, 0], [-1, 0], [0, 1], [0, -1],  // Xung quanh g·∫ßn
  [2, 0], [-2, 0], [0, 2], [0, -2],  // Xa h∆°n
  [1, 1], [-1, 1], [1, -1], [-1, -1], // Ch√©o
  [2, 1], [-2, 1], [2, -1], [-2, -1], // Ch√©o xa h∆°n
  [1, 2], [-1, 2], [1, -2], [-1, -2]  // Ch√©o d·ªçc xa
];

let board = [];
let currentPiece;
let score = 0;
let level = 1;
let baseDropInterval = 1000; // T·ªëc ƒë·ªô g·ªëc: 1 gi√¢y
let currentDropInterval = 1000;
let gameRunning = false;
let dropTimer = null;
let gamePaused = false;
let totalLinesCleared = 0;

// Sound variables
let soundEnabled = true;
let lastMoveTime = 0;
const MOVE_SOUND_DELAY = 100; // ms

// Touch control variables
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;
let isDragging = false;
let dragStartPieceX = 0;

// QR Code variables
let qrCode = null;
const GAME_URL = "https://tin86pc.github.io/XepHinh/";

// Sensitivity settings
const SWIPE_THRESHOLD = 40;
const TAP_THRESHOLD = 200;
const TAP_MOVE_THRESHOLD = 15;
const DRAG_THRESHOLD = 10;

// ===================== T·ªêC ƒê·ªò THEO LEVEL (LOGARITHMIC) =====================
function calculateDropInterval(level) {
  // C√¥ng th·ª©c logarithm: t·ªëc ƒë·ªô tƒÉng nhanh ·ªü level th·∫•p, ch·∫≠m d·∫ßn ·ªü level cao
  // Gi·∫£m d·∫ßn theo h√†m m≈©: interval = base * (0.85^(level-1))
  
  // Level 1: 1000ms (1 gi√¢y)
  // Level 2: 850ms (gi·∫£m 15%)
  // Level 3: 722ms (gi·∫£m 15%)
  // Level 4: 614ms (gi·∫£m 15%)
  // Level 5: 522ms (gi·∫£m 15%)
  // Level 10: ~200ms (t·ªïng gi·∫£m 80%)
  // Level 15: ~100ms (t·ªïng gi·∫£m 90%)
  // Level 20+: ~50ms (gi·ªõi h·∫°n t·ªëi thi·ªÉu)
  
  const baseInterval = 1000; // ms cho level 1
  const reductionFactor = 0.85; // M·ªói level gi·∫£m 15%
  const minInterval = 50; // T·ªëc ƒë·ªô t·ªëi ƒëa: 50ms (20 kh·ªëi/gi√¢y)
  
  // T√≠nh t·ªëc ƒë·ªô m·ªõi
  let newInterval = baseInterval * Math.pow(reductionFactor, level - 1);
  
  // ƒê·∫£m b·∫£o kh√¥ng v∆∞·ª£t qu√° t·ªëc ƒë·ªô t·ªëi ƒëa
  newInterval = Math.max(minInterval, newInterval);
  
  // L√†m tr√≤n ƒë·∫øn 10ms g·∫ßn nh·∫•t
  newInterval = Math.round(newInterval / 10) * 10;
  
  return newInterval;
}

function updateSpeedDisplay() {
  // T√≠nh t·ªëc ƒë·ªô hi·ªÉn th·ªã (1x = 1000ms, 2x = 500ms, v.v.)
  const speedMultiplier = Math.round((1000 / currentDropInterval) * 10) / 10;
  document.getElementById("speed").textContent = speedMultiplier.toFixed(1) + "x";
}

// ===================== SOUND FUNCTIONS =====================
function initAudio() {
  // T·∫°o √¢m thanh ƒë∆°n gi·∫£n b·∫±ng Web Audio API
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  // H√†m t·∫°o √¢m thanh ƒë∆°n gi·∫£n
  function createBeep(duration, frequency, type) {
    if (!soundEnabled) return;
    
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
      console.log("Kh√¥ng th·ªÉ ph√°t √¢m thanh:", e);
    }
  }
  
  // G√°n c√°c h√†m t·∫°o √¢m thanh
  window.playMoveSound = () => {
    const now = Date.now();
    if (now - lastMoveTime > MOVE_SOUND_DELAY) {
      createBeep(0.05, 200, 'sine');
      lastMoveTime = now;
    }
  };
  
  window.playRotateSound = () => {
    if (soundEnabled) createBeep(0.1, 300, 'sine');
  };
  
  window.playDropSound = () => {
    if (soundEnabled) createBeep(0.15, 150, 'sine');
  };
  
  window.playLineSound = () => {
    if (soundEnabled) createBeep(0.2, 600, 'square');
  };
  
  window.playLevelUpSound = () => {
    if (soundEnabled) {
      createBeep(0.1, 600, 'sine');
      setTimeout(() => createBeep(0.1, 800, 'sine'), 100);
      setTimeout(() => createBeep(0.2, 1000, 'sine'), 200);
    }
  };
  
  window.playGameOverSound = () => {
    if (soundEnabled) {
      createBeep(0.3, 200, 'sawtooth');
      setTimeout(() => createBeep(0.3, 150, 'sawtooth'), 300);
      setTimeout(() => createBeep(0.5, 100, 'sawtooth'), 600);
    }
  };
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  const soundBtn = document.getElementById('soundBtn');
  
  if (soundEnabled) {
    soundBtn.innerHTML = 'üîä';
    soundBtn.classList.remove('muted');
    soundBtn.classList.add('sound');
    // Play a test sound when turning on
    setTimeout(() => {
      if (soundEnabled) {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 400;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }
    }, 100);
  } else {
    soundBtn.innerHTML = 'üîá';
    soundBtn.classList.remove('sound');
    soundBtn.classList.add('muted');
  }
}

// ===================== FULLSCREEN FUNCTIONS =====================
function toggleFullscreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`L·ªói khi v√†o ch·∫ø ƒë·ªô to√†n m√†n h√¨nh: ${err.message}`);
    });
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
}

// ===================== QR CODE FUNCTIONS =====================
function generateQRCode(elementId = 'qrcode') {
  // X√≥a QR code c≈© n·∫øu c√≥
  const qrcodeDiv = document.getElementById(elementId);
  if (!qrcodeDiv) return;
  
  qrcodeDiv.innerHTML = '';
  
  // T·∫°o QR code m·ªõi
  try {
    new QRCode(qrcodeDiv, {
      text: GAME_URL,
      width: 150,
      height: 150,
      colorDark: "#000000",
      colorLight: "#ffffff",
      correctLevel: QRCode.CorrectLevel.H
    });
  } catch (e) {
    console.log("L·ªói t·∫°o QR code:", e);
  }
}

function updatePauseOverlay() {
  if (gamePaused) {
    // Generate QR code when pausing
    setTimeout(() => generateQRCode('qrcode'), 50);
  }
}

// ===================== GAME FUNCTIONS =====================
function createBoard() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
}

function createPiece() {
  const type = Math.floor(Math.random() * 7) + 1;
  const shape = SHAPES[type][0].map(row => [...row]);
  
  // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ ban ƒë·∫ßu cho kh·ªëi I
  let startX = Math.floor(COLS/2) - Math.floor(shape[0].length/2);
  if (type === 1) {
    // Kh·ªëi I c·∫ßn offset kh√°c v√¨ n√≥ d√†i 4 block
    startX = Math.max(0, Math.min(COLS - shape[0].length, startX));
  }
  
  return {
    type,
    shape: shape,
    rotation: 0,
    x: startX,
    y: type === 1 ? -1 : 0  // Kh·ªëi I c·∫ßn b·∫Øt ƒë·∫ßu cao h∆°n
  };
}

function collide(px, py, shape) {
  for (let y = 0; y < shape.length; y++) {
    for (let x = 0; x < shape[y].length; x++) {
      if (shape[y][x]) {
        const nx = px + x;
        const ny = py + y;
        
        // Ki·ªÉm tra va ch·∫°m v·ªõi t∆∞·ªùng v√† ƒë√°y
        if (nx < 0 || nx >= COLS || ny >= ROWS) {
          return true;
        }
        
        // Ki·ªÉm tra va ch·∫°m v·ªõi c√°c block ƒë√£ ƒë·∫∑t (ch·ªâ khi ny >= 0)
        if (ny >= 0 && board[ny][nx]) {
          return true;
        }
      }
    }
  }
  return false;
}

function merge() {
  currentPiece.shape.forEach((row, y) => {
    row.forEach((v, x) => {
      if (v) {
        const boardY = currentPiece.y + y;
        const boardX = currentPiece.x + x;
        if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
          board[boardY][boardX] = currentPiece.type;
        }
      }
    });
  });
}

function rotatePiece() {
  // Kh·ªëi O kh√¥ng xoay
  if (currentPiece.type === 2) {
    return false;
  }
  
  // L∆∞u tr·∫°ng th√°i hi·ªán t·∫°i
  const originalShape = currentPiece.shape.map(row => [...row]);
  const originalX = currentPiece.x;
  const originalY = currentPiece.y;
  const originalRotation = currentPiece.rotation;
  
  // T√≠nh rotation m·ªõi
  const newRotation = (currentPiece.rotation + 1) % 4;
  const newShape = SHAPES[currentPiece.type][newRotation].map(row => [...row]);
  
  // L·∫•y wall kicks ph√π h·ª£p
  const kickSet = currentPiece.type === 1 ? WALL_KICKS[1] : WALL_KICKS.default;
  const kickKey = `${originalRotation}->${newRotation}`;
  const kicks = kickSet[kickKey] || [[0,0]];
  
  // Th·ª≠ t·∫•t c·∫£ c√°c wall kick theo chu·∫©n
  for (const [kx, ky] of kicks) {
    const testX = originalX + kx;
    const testY = originalY + ky;
    
    // Ki·ªÉm tra xem c√≥ th·ªÉ xoay ·ªü v·ªã tr√≠ n√†y kh√¥ng
    if (!collide(testX, testY, newShape)) {
      // C·∫≠p nh·∫≠t piece m·ªõi
      currentPiece.shape = newShape;
      currentPiece.rotation = newRotation;
      currentPiece.x = testX;
      currentPiece.y = testY;
      
      // Ph√°t √¢m thanh xoay
      if (gameRunning && !gamePaused) {
        playRotateSound();
      }
      
      return true;
    }
  }
  
  // N·∫øu kh√¥ng c√≥ wall kick n√†o ho·∫°t ƒë·ªông, th·ª≠ c√°c extra kicks
  if (currentPiece.type >= 3 && currentPiece.type <= 7) {
    const priorityKicks = [
      [0, 0],    // G·ªëc
      [1, 0], [-1, 0], // Tr√°i ph·∫£i
      [2, 0], [-2, 0], // Xa h∆°n
      [0, -1], [0, -2], // L√™n
      [1, -1], [-1, -1], // Ch√©o l√™n
      [1, 1], [-1, 1]  // Ch√©o xu·ªëng
    ];
    
    // Th·ª≠ c√°c kick c√≥ ƒë·ªô ∆∞u ti√™n
    for (const [kx, ky] of priorityKicks) {
      const testX = originalX + kx;
      const testY = originalY + ky;
      
      if (!collide(testX, testY, newShape)) {
        // C·∫≠p nh·∫≠t piece m·ªõi
        currentPiece.shape = newShape;
        currentPiece.rotation = newRotation;
        currentPiece.x = testX;
        currentPiece.y = testY;
        
        // Ph√°t √¢m thanh xoay
        if (gameRunning && !gamePaused) {
          playRotateSound();
        }
        
        return true;
      }
    }
    
    // N·∫øu v·∫´n kh√¥ng ƒë∆∞·ª£c, th·ª≠ t·∫•t c·∫£ c√°c extra kicks
    for (const [kx, ky] of EXTRA_KICKS) {
      const testX = originalX + kx;
      const testY = originalY + ky;
      
      if (!collide(testX, testY, newShape)) {
        // C·∫≠p nh·∫≠t piece m·ªõi
        currentPiece.shape = newShape;
        currentPiece.rotation = newRotation;
        currentPiece.x = testX;
        currentPiece.y = testY;
        
        // Ph√°t √¢m thanh xoay
        if (gameRunning && !gamePaused) {
          playRotateSound();
        }
        
        return true;
      }
    }
  }
  
  // Kh√¥ng th·ªÉ xoay - kh√¥i ph·ª•c tr·∫°ng th√°i c≈©
  currentPiece.shape = originalShape;
  currentPiece.x = originalX;
  currentPiece.y = originalY;
  currentPiece.rotation = originalRotation;
  
  // V·∫´n ph√°t √¢m thanh d√π kh√¥ng xoay ƒë∆∞·ª£c
  if (gameRunning && !gamePaused) {
    playMoveSound();
  }
  
  return false;
}

function clearLines() {
  let linesCleared = 0;
  for (let y = ROWS - 1; y >= 0; y--) {
    if (board[y].every(v => v)) {
      board.splice(y, 1);
      board.unshift(Array(COLS).fill(0));
      linesCleared++;
      y++; // Check same row again
    }
  }
  
  if (linesCleared > 0) {
    totalLinesCleared += linesCleared;
    
    // Score calculation: 40, 100, 300, 1200 points for 1-4 lines
    const linePoints = [0, 40, 100, 300, 1200];
    score += linePoints[linesCleared] * level;
    
    // Level up m·ªói 5 d√≤ng ƒë√£ x√≥a (thay v√¨ m·ªói 1000 ƒëi·ªÉm)
    const newLevel = Math.floor(totalLinesCleared / 5) + 1;
    
    if (newLevel > level) {
      level = newLevel;
      
      // C·∫≠p nh·∫≠t t·ªëc ƒë·ªô m·ªõi theo level
      const newDropInterval = calculateDropInterval(level);
      
      // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu t·ªëc ƒë·ªô thay ƒë·ªïi ƒë√°ng k·ªÉ (> 10ms)
      if (Math.abs(newDropInterval - currentDropInterval) > 10) {
        currentDropInterval = newDropInterval;
        
        // C·∫≠p nh·∫≠t interval n·∫øu game ƒëang ch·∫°y
        if (dropTimer) {
          clearInterval(dropTimer);
          dropTimer = setInterval(drop, currentDropInterval);
        }
        
        // Ph√°t √¢m thanh level up
        if (gameRunning && !gamePaused) {
          playLevelUpSound();
        }
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªëc ƒë·ªô
        updateSpeedDisplay();
      }
    }
    
    document.getElementById("score").textContent = score;
    document.getElementById("level").textContent = level;
    
    // Ph√°t √¢m thanh x√≥a d√≤ng
    if (gameRunning && !gamePaused) {
      playLineSound();
    }
  }
  
  return linesCleared;
}

function drawBlock(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK - 1, BLOCK - 1);
  
  // Add highlight effect
  ctx.fillStyle = "rgba(255,255,255,0.2)";
  ctx.fillRect(x * BLOCK + 2, y * BLOCK + 2, BLOCK - 5, 3);
  ctx.fillRect(x * BLOCK + 2, y * BLOCK + 2, 3, BLOCK - 5);
  
  // Add shadow
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.fillRect(x * BLOCK + 2, y * BLOCK + BLOCK - 3, BLOCK - 5, 3);
  ctx.fillRect(x * BLOCK + BLOCK - 3, y * BLOCK + 2, 3, BLOCK - 5);
}

function draw() {
  // Clear canvas with gradient background
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw grid background
  ctx.strokeStyle = "rgba(90, 62, 255, 0.1)";
  ctx.lineWidth = 1;
  
  // Vertical lines
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * BLOCK, 0);
    ctx.lineTo(x * BLOCK, ROWS * BLOCK);
    ctx.stroke();
  }
  
  // Horizontal lines
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * BLOCK);
    ctx.lineTo(COLS * BLOCK, y * BLOCK);
    ctx.stroke();
  }
  
  // Draw placed blocks
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (board[y][x]) {
        drawBlock(x, y, COLORS[board[y][x]]);
      }
    }
  }
  
  // Draw current piece
  if (currentPiece) {
    for (let y = 0; y < currentPiece.shape.length; y++) {
      for (let x = 0; x < currentPiece.shape[y].length; x++) {
        if (currentPiece.shape[y][x]) {
          const drawX = currentPiece.x + x;
          const drawY = currentPiece.y + y;
          if (drawY >= -1) {
            drawBlock(drawX, drawY, COLORS[currentPiece.type]);
          }
        }
      }
    }
  }
}

function drop() {
  if (!gameRunning || !currentPiece || gamePaused) return;
  
  if (!collide(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
    currentPiece.y++;
  } else {
    // Ph√°t √¢m thanh ƒë·∫∑t kh·ªëi
    if (soundEnabled) {
      playDropSound();
    }
    
    merge();
    const linesCleared = clearLines();
    currentPiece = createPiece();
    
    if (collide(currentPiece.x, currentPiece.y, currentPiece.shape)) {
      gameRunning = false;
      
      // Ph√°t √¢m thanh game over
      if (soundEnabled) {
        playGameOverSound();
      }
      
      pauseOverlay.innerHTML = `
        <div class="pause-title">üéÆ GAME OVER</div>
        <div class="pause-text">ƒêi·ªÉm: ${score}</div>
        <div class="pause-text">Level: ${level}</div>
        <div class="pause-text">T·ªëc ƒë·ªô: ${(1000/currentDropInterval).toFixed(1)}x</div>
        <div class="pause-text">D√≤ng ƒë√£ x√≥a: ${totalLinesCleared}</div>
        <div class="pause-text">Ch·∫°m m√†n h√¨nh ƒë·ªÉ ch∆°i l·∫°i</div>
        
        <!-- QR Code Section -->
        <div class="qr-container">
          <div class="qr-title">üîó Chia s·∫ª game n√†y:</div>
          <div id="qrcode"></div>
          <div class="qr-link">${GAME_URL}</div>
        </div>
      `;
      pauseOverlay.classList.add('show');
      document.getElementById('pauseBtn').innerHTML = '‚è∏Ô∏è';
      clearInterval(dropTimer);
      
      // Generate QR code for game over screen
      setTimeout(() => generateQRCode('qrcode'), 50);
    }
  }
  draw();
}

function startGame() {
  createBoard();
  currentPiece = createPiece();
  score = 0;
  level = 1;
  totalLinesCleared = 0;
  baseDropInterval = 1000;
  currentDropInterval = calculateDropInterval(level);
  
  document.getElementById("score").textContent = "0";
  document.getElementById("level").textContent = "1";
  updateSpeedDisplay();
  pauseOverlay.classList.remove('show');
  
  gameRunning = true;
  gamePaused = false;
  document.getElementById('pauseBtn').innerHTML = '‚è∏Ô∏è';
  
  draw();
  
  if (dropTimer) clearInterval(dropTimer);
  dropTimer = setInterval(drop, currentDropInterval);
  
  // ·∫®n hint sau 3 gi√¢y
  setTimeout(() => {
    tapHint.style.opacity = '0';
    setTimeout(() => {
      tapHint.style.display = 'none';
    }, 500);
  }, 3000);
}

// H√†m reset game khi ch·∫°m v√†o m√†n h√¨nh game over
function resetGame() {
  if (dropTimer) clearInterval(dropTimer);
  gameRunning = false;
  setTimeout(startGame, 100);
}

function togglePause() {
  if (!gameRunning) return;
  
  gamePaused = !gamePaused;
  if (gamePaused) {
    updatePauseOverlay();
    pauseOverlay.classList.add('show');
    document.getElementById('pauseBtn').innerHTML = '‚ñ∂Ô∏è';
    clearInterval(dropTimer);
  } else {
    pauseOverlay.classList.remove('show');
    document.getElementById('pauseBtn').innerHTML = '‚è∏Ô∏è';
    dropTimer = setInterval(drop, currentDropInterval);
    draw();
  }
}

// ===================== RESIZE CANVAS =====================
function resizeCanvas() {
  const header = document.querySelector('.game-header');
  const controls = document.querySelector('.controls-container');
  
  const headerHeight = header.offsetHeight;
  const controlsHeight = controls.offsetHeight;
  
  const availableWidth = window.innerWidth;
  const availableHeight = window.innerHeight - headerHeight - controlsHeight;
  
  const gameRatio = COLS / ROWS; // 0.5
  
  let canvasWidth, canvasHeight;
  
  if (availableWidth / availableHeight > gameRatio) {
    // Fit by height
    canvasHeight = availableHeight;
    canvasWidth = Math.floor(canvasHeight * gameRatio);
  } else {
    // Fit by width
    canvasWidth = availableWidth;
    canvasHeight = Math.floor(canvasWidth / gameRatio);
  }
  
  // Set canvas display size
  canvas.style.width = canvasWidth + 'px';
  canvas.style.height = canvasHeight + 'px';
  
  // Set canvas drawing buffer size
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;
  
  // Redraw game
  if (gameRunning) draw();
}

// ===================== EVENT LISTENERS =====================
// Window resize
window.addEventListener("resize", resizeCanvas);
window.addEventListener("orientationchange", () => {
  setTimeout(resizeCanvas, 100);
});

// Fullscreen change
document.addEventListener('fullscreenchange', () => {
  setTimeout(resizeCanvas, 100);
});

// ===================== INITIALIZATION =====================
function initGame() {
  // Kh·ªüi t·∫°o √¢m thanh
  initAudio();
  
  // Kh·ªüi t·∫°o game
  startGame();
  setTimeout(resizeCanvas, 100);
  
  console.log("X·∫øp H√¨nh - Game x·∫øp h√¨nh cho ƒëi·ªán tho·∫°i");
  console.log("T·ªëc ƒë·ªô tƒÉng theo level: nhanh ·ªü level th·∫•p, ch·∫≠m ·ªü level cao");
  console.log("Level 1: 1000ms, Level 10: ~200ms, Level 20+: ~50ms");
}

// Ch·∫°y khi trang ƒë√£ t·∫£i xong
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initGame);
} else {
  initGame();
}

// ===================== KEYBOARD CONTROLS =====================
document.addEventListener("keydown", e => {
  if (!gameRunning || gamePaused) return;
  
  e.preventDefault();
  
  switch(e.key) {
    case "ArrowLeft":
      if (!collide(currentPiece.x - 1, currentPiece.y, currentPiece.shape)) {
        currentPiece.x--;
        draw();
        playMoveSound();
      }
      break;
      
    case "ArrowRight":
      if (!collide(currentPiece.x + 1, currentPiece.y, currentPiece.shape)) {
        currentPiece.x++;
        draw();
        playMoveSound();
      }
      break;
      
    case "ArrowDown":
      if (!collide(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
        currentPiece.y++;
        draw();
        playMoveSound();
      }
      break;
      
    case "ArrowUp":
      rotatePiece();
      draw();
      break;
      
    case " ":
      // Space bar - hard drop
      while (!collide(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
        currentPiece.y++;
      }
      drop();
      break;
      
    case "p":
    case "P":
      togglePause();
      break;
      
    case "m":
    case "M":
      toggleSound();
      break;
      
    case "f":
    case "F":
      toggleFullscreen();
      break;
  }
});

// ===================== TOUCH CONTROLS =====================
canvas.addEventListener("touchstart", e => {
  if (gamePaused) return;
  
  // N·∫øu game ƒëang ch·∫°y, x·ª≠ l√Ω di chuy·ªÉn
  if (gameRunning) {
    e.preventDefault();
    
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchStartTime = Date.now();
    isDragging = false;
    dragStartPieceX = currentPiece.x;
  }
  // N·∫øu game over, reset game khi ch·∫°m v√†o m√†n h√¨nh
  else if (!gameRunning && pauseOverlay.classList.contains('show')) {
    resetGame();
    pauseOverlay.classList.remove('show');
  }
});

canvas.addEventListener("touchmove", e => {
  if (!gameRunning || gamePaused) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  const deltaX = Math.abs(touch.clientX - touchStartX);
  const deltaY = Math.abs(touch.clientY - touchStartY);
  
  // Start dragging if horizontal movement is significant
  if (!isDragging && deltaX > DRAG_THRESHOLD && deltaX > deltaY) {
    isDragging = true;
  }
  
  if (isDragging) {
    const pixelDiff = touch.clientX - touchStartX;
    const blockSize = canvas.width / COLS;
    const blockDiff = Math.round(pixelDiff / (blockSize * 0.8));
    const targetX = dragStartPieceX + blockDiff;
    
    // Move piece smoothly to target position
    if (targetX > currentPiece.x) {
      for (let i = currentPiece.x + 1; i <= targetX; i++) {
        if (!collide(i, currentPiece.y, currentPiece.shape)) {
          currentPiece.x = i;
          playMoveSound();
        } else {
          break;
        }
      }
    } else if (targetX < currentPiece.x) {
      for (let i = currentPiece.x - 1; i >= targetX; i--) {
        if (!collide(i, currentPiece.y, currentPiece.shape)) {
          currentPiece.x = i;
          playMoveSound();
        } else {
          break;
        }
      }
    }
    
    draw();
  }
});

canvas.addEventListener("touchend", e => {
  if (gamePaused || !gameRunning) return;
  e.preventDefault();
  
  const touch = e.changedTouches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  const deltaTime = Date.now() - touchStartTime;
  
  const absDeltaX = Math.abs(deltaX);
  const absDeltaY = Math.abs(deltaY);
  
  // If dragging was happening, just end it
  if (isDragging) {
    isDragging = false;
    return;
  }
  
  // Handle tap and swipe gestures
  if (deltaTime < TAP_THRESHOLD && absDeltaX < TAP_MOVE_THRESHOLD && absDeltaY < TAP_MOVE_THRESHOLD) {
    // Tap - rotate piece
    rotatePiece();
    draw();
  } else if (absDeltaY > SWIPE_THRESHOLD) {
    // Swipe vertical
    if (deltaY > 0) {
      // Swipe down - hard drop
      while (!collide(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
        currentPiece.y++;
      }
      drop();
    } else {
      // Swipe up - rotate
      rotatePiece();
      draw();
    }
  }
});

// ===================== PREVENT UNWANTED BEHAVIOR =====================
document.addEventListener('touchmove', function(e) {
  if (e.target === canvas || e.target.closest('.main-game-area')) {
    e.preventDefault();
  }
}, { passive: false });

canvas.addEventListener('contextmenu', e => e.preventDefault());
</script>

</body>
</html>